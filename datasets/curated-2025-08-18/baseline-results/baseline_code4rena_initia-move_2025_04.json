{
  "project": "code4rena_initia-move_2025_04",
  "timestamp": "2025-09-02T01:13:05.726830",
  "files_analyzed": 11,
  "files_skipped": 0,
  "total_findings": 23,
  "findings": [
    {
      "title": "Mismatched vector handling inflates total_tally and enables outcome manipulation",
      "description": "In vote(), the contract computes weight_sum by iterating over the entire weights vector, but then constructs the actual voting pairs using vector::zip_reverse(bridge_ids, weights, ...), which only pairs up to min(len(bridge_ids), len(weights)) and silently drops any extra items. Next, apply_vote() updates per-bridge tallies only for the paired subset, but proposal.total_tally is increased by voting_power_used computed from the full weight_sum of all provided weights. This accounting mismatch allows an attacker to pass many extra weights (with sum close to 1) while providing very few bridge_ids. The result is a large increase to proposal.total_tally without a corresponding increase to any bridge tallies. Later, remove_vote() subtracts only the per-bridge amounts that were actually applied (paired subset), leaving the inflated excess in total_tally. Because execute_proposal_internal() computes each bridge's final weight as tally_i / total_tally, an attacker can inflate the denominator so much that all resulting weights approach zero, effectively nullifying the vote outcome.",
      "vulnerability_type": "logic/precision bug leading to protocol manipulation",
      "severity": "critical",
      "confidence": 0.95,
      "location": "vote() (weight_sum over all weights; vector::zip_reverse pairing); apply_vote(); remove_vote(); execute_proposal_internal()",
      "file": "weight_vote.move",
      "id": "6ce2cdcd644fb886",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Rounding/truncation mismatch lets voters inflate total_tally by repeatedly updating votes",
      "description": "apply_vote() increments proposal.total_tally by voting_power_used = floor(sum(weights) * max_voting_power), while it increments per-bridge tallies by \u03a3 floor(weight_i * max_voting_power). Due to truncation, floor(sum) can be strictly greater than \u03a3 floor(parts). Conversely, remove_vote() decrements proposal.total_tally by \u03a3 floor(weight_i * max_voting_power). Therefore, a voter can repeatedly toggle between a split-weight vote (with many small weights summing to 1) and a zero-weight vote within the same cycle to accumulate a net increase of [floor(sum) \u2212 \u03a3 floor(parts)] in total_tally each iteration, while restoring bridge tallies back to their prior values. Over time, this inflates the denominator used in execute_proposal_internal(), reducing all computed bridge weights and allowing manipulation of the final outcome.",
      "vulnerability_type": "logic/precision bug",
      "severity": "high",
      "confidence": 0.9,
      "location": "apply_vote(); remove_vote(); execute_proposal_internal()",
      "file": "weight_vote.move",
      "id": "832d69a5cd4ec5a3",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "No validation of lock period multipliers can cause DoS via arithmetic underflow",
      "description": "update_params() allows setting min_lock_period_multiplier and max_lock_period_multiplier without validating their relationship. In get_lock_period_multiplier(), the code computes (max_multiplier - min_multiplier); if max_multiplier < min_multiplier, this subtraction underflows and aborts. Because get_lock_period_multiplier() is used inside get_voting_power(), any call that evaluates lock-staked voting power (e.g., vote()) will abort, causing denial of service for affected users or globally if many accounts have lock-staked positions.",
      "vulnerability_type": "input validation / arithmetic underflow leading to DoS",
      "severity": "medium",
      "confidence": 0.85,
      "location": "update_params(); get_lock_period_multiplier()",
      "file": "weight_vote.move",
      "id": "daeaacbfd1c73c05",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Division-by-zero when no whitelisted bridges exist blocks proposal execution",
      "description": "execute_proposal_internal() computes equal weights as bigdecimal::from_ratio_u64(1, len) when proposal.total_tally == 0. If the whitelisted bridge list is empty (len == 0), this divides by zero and aborts, preventing proposal execution. This can lock the proposal lifecycle and cause a denial of service if configuration or admin actions temporarily leave zero whitelisted bridges.",
      "vulnerability_type": "denial of service via division by zero",
      "severity": "low",
      "confidence": 0.8,
      "location": "execute_proposal_internal()",
      "file": "weight_vote.move",
      "id": "043e5ae4b2039c46",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Incorrect argument length validation in batch_extend enables out-of-bounds access",
      "description": "The batch_extend entry function validates that the input vectors have the same length using logical OR instead of AND. Specifically, it asserts: len == length(amounts) || len == length(release_times) || len == length(validators) || len == length(new_release_times). This passes if any single vector matches the metadata vector length, allowing others to be shorter. The subsequent loop then does vector::borrow on all vectors up to len, which can read out of bounds and abort the transaction. While state changes are reverted on abort, this is a real input-validation bug that can cause unexpected failures and denial of service for the caller of this function.",
      "vulnerability_type": "input validation / denial of service",
      "severity": "low",
      "confidence": 0.75,
      "location": "batch_extend() entry function",
      "file": "lock_staking.move",
      "id": "bdcb5d2e0e74e61e",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unsafe Option extraction in get_exact_provide_amount causes abort on empty pool",
      "description": "get_exact_provide_amount calls option::extract(&mut fungible_asset::supply(pair)) without checking that the Option is Some. On a fresh or empty pool where supply is None, this will abort the transaction, preventing provide_delegate from functioning for initial liquidity. This creates a denial-of-service for the provide_delegate/single-asset flows on pools with no existing liquidity.",
      "vulnerability_type": "denial of service",
      "severity": "low",
      "confidence": 0.7,
      "location": "get_exact_provide_amount() function, used by provide_delegate()",
      "file": "lock_staking.move",
      "id": "51661be15519e39b",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Price oracle manipulation in fee calculation enables underpayment and potential DoS",
      "description": "The cost to register/extend a domain is computed using a mutable DEX spot price without any safeguards. In get_cost_amount(), the module reads spot_price via dex::get_spot_price and computes price = usd_value / spot_price, then truncates to u64. An attacker can manipulate the on-chain DEX price (e.g., with low liquidity or short-term trades) to drive spot_price artificially high to reduce fees to near zero, or near zero to cause division by a tiny number leading to extremely large costs or even division by zero. This directly impacts register_domain() and extend_expiration(), enabling users to underpay to register/extend or causing those functions to abort (DoS) when spot_price is 0 or the computed BigDecimal overflows u64 during truncate_u64().\n- Where: get_cost_amount() (fee computation using dex::get_spot_price); invoked from register_domain() and extend_expiration().\n- Why: Using an unprotected, manipulable spot price as an oracle is unsafe; no TWAP, min liquidity checks, bounds, or non-manipulable oracle are used. Division by zero or overflow paths can abort transactions.\n- Impact: Loss of protocol revenue (users register/extend at near-zero cost), economic manipulation, and Denial of Service by making registrations/renewals revert when spot_price is 0 or causes overflow.",
      "vulnerability_type": "oracle manipulation / economic attack / denial of service",
      "severity": "high",
      "confidence": 0.9,
      "location": "get_cost_amount(), register_domain(), extend_expiration()",
      "file": "name_service.move",
      "id": "240f1d005cdb72a9",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Stale reverse-lookup mappings cause aborts in view functions (DoS)",
      "description": "When a domain expires and is reclaimed, the code removes the name_to_token entry but does not clear name_to_addr and addr_to_name. The is_expired(name) helper then blindly unwraps get_valid_token(name) with *option::borrow(...) and will abort if name_to_token no longer contains that name. Both get_name_from_address() and get_address_from_name() call is_expired(name) after confirming the corresponding mapping exists, leading to an abort when the token mapping was removed earlier.\n- Where: register_domain() (expired path removes name_to_token but does not clear name_to_addr/addr_to_name); is_expired() (unchecked option::borrow on get_valid_token(name)); get_name_from_address(); get_address_from_name().\n- Why: Unchecked Option unwrapping on a derived lookup combined with inconsistent state leaves getters aborting instead of returning none when a name was reclaimed.\n- Impact: Denial of Service for on-chain callers or off-chain queries relying on these view functions; any user whose domain expired and was reclaimed can cause lookups to abort for their address/name until mappings are reset by a later set_name.",
      "vulnerability_type": "denial of service / unchecked option",
      "severity": "medium",
      "confidence": 0.95,
      "location": "register_domain() expired-branch; is_expired(); get_name_from_address(); get_address_from_name()",
      "file": "name_service.move",
      "id": "6fcd5324fe93485c",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Anyone can extend expiration of any domain (missing ownership/auth check)",
      "description": "extend_expiration() allows any caller to extend the expiration of a domain without verifying ownership of the corresponding token. The function only lowercases the name, looks up the token in name_to_token, computes a new expiration, and charges the caller. No owner check is performed (unlike set_name/update_records/delete_records which enforce ownership).\n- Where: extend_expiration().\n- Why: Missing authorization allows third parties to keep another user's domain from entering the re-registration window by continuously paying the minimum duration, potentially indefinitely preventing others from registering it.\n- Impact: Economic DoS on domain turnover/availability. Attackers can block desirable names from becoming available after grace by repeatedly renewing them at minimal cost. While the attacker pays, this may still be undesirable and against expected authorization semantics.",
      "vulnerability_type": "access control / authorization",
      "severity": "medium",
      "confidence": 0.6,
      "location": "extend_expiration()",
      "file": "name_service.move",
      "id": "376f4717c562344b",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Division-by-zero risk when creating user vesting (end_stage == start_stage)",
      "description": "In create_user_vesting(), vest_max_amount is calculated as vesting_reward_amount / (claim_info.end_stage - claim_info.start_stage). If end_stage equals start_stage, this division by zero will abort the transaction. Where: create_user_vesting() (called from batch_claim_user_reward()), at the vest_max_amount calculation. Why: Missing validation that end_stage > start_stage allows malformed claim data to trigger a runtime abort. Impact: Denial of service for user claim processing; the entire batch claim reverts, blocking distribution until corrected input is provided.",
      "vulnerability_type": "arithmetic error / input validation / denial of service",
      "severity": "medium",
      "confidence": 0.78,
      "location": "create_user_vesting() vest_max_amount computation; invoked from batch_claim_user_reward()",
      "file": "vesting.move",
      "id": "9bf5ef31ae7c162f",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Arithmetic underflow/zero-division in operator reward claiming if last_submitted_stage < start_stage or end_stage == start_stage",
      "description": "In batch_claim_operator_reward(), after inserting new operator vestings, the function iterates all operator_vestings with utils::walk_mut and computes: stage_diff = last_submitted_stage - operator_vesting.start_stage and vesting_period = operator_vesting.end_stage - operator_vesting.start_stage. If last_submitted_stage is less than start_stage, stage_diff underflows and aborts. If end_stage equals start_stage, vesting_period is zero and the subsequent utils::mul_div_u64(..., vesting_period) divides by zero. Where: batch_claim_operator_reward(), in the utils::walk_mut closure that calculates reward_amount. Why: Missing validation on stage ordering and last_submitted_stage relative to vesting start. Impact: A single malformed claim (e.g., future-dated start_stage or zero-length vesting) causes the entire operator claim transaction to revert, preventing operator reward distribution and enabling denial of service.",
      "vulnerability_type": "arithmetic error / denial of service",
      "severity": "high",
      "confidence": 0.84,
      "location": "batch_claim_operator_reward() walk over operator_vestings: stage_diff and vesting_period calculations",
      "file": "vesting.move",
      "id": "5c4d2b30548b13f1",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Operator rewards can be claimed before challenge period ends",
      "description": "The batch_claim_operator_reward_script function allows operators to claim rewards up to the latest submitted stage without enforcing the challenge period. Unlike user claims (batch_claim_user_reward_script), which call is_after_challenge_period to ensure the challenge window has passed, the operator path only checks that snapshots exist and builds vesting claim info, then deposits funds. This occurs in batch_claim_operator_reward_script (search for 'batch_claim_operator_reward_script'), where the loop from last_claimed_stage + 1 to last_submitted_stage lacks any check analogous to is_after_challenge_period. As a result, an operator can front-run the challenge window and withdraw rewards immediately after a snapshot is submitted, before challenges can be raised. If a challenge later invalidates or modifies a snapshot, the operator may have already withdrawn funds, leading to potential loss of funds for the protocol or users, and undermining the integrity of the challenge mechanism.",
      "vulnerability_type": "improper validation/business logic",
      "severity": "high",
      "confidence": 0.85,
      "location": "batch_claim_operator_reward_script()",
      "file": "vip.move",
      "id": "80862705d3967a1b",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Missing invariants in create allows inconsistent record_keys/record_values lengths",
      "description": "The create function stores record_keys and record_values without verifying they have equal lengths. Subsequent logic in update_records and delete_records assumes a 1:1 alignment by index. If a Metadata is created with mismatched lengths (e.g., more keys than values), later operations will index into record_values using an index derived from record_keys and can abort with out-of-bounds errors. This can brick record management for the token and cause denial of service for any features relying on updating or deleting records.\n- Where: create(...) (no length checks); impact manifests in update_records(...) and delete_records(...)\n- Why it's a security issue: Invariant violation enables state corruption that leads to reliable aborts in state-mutating functions, effectively DoS\u2019ing record updates/deletions for the affected token.\n- Potential impact: Persistent denial of service for record maintenance; potential downstream app errors if they expect aligned key/value pairs.",
      "vulnerability_type": "input validation / invariant violation leading to denial of service",
      "severity": "medium",
      "confidence": 0.85,
      "location": "create(token, expiration_date, name, record_keys, record_values) function",
      "file": "metadata.move",
      "id": "ed62d73fe6bd17f5",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "MAX_RECORD limit not enforced on create enabling oversized records and subsequent DoS",
      "description": "The create function does not enforce the MAX_RECORD limit, while update_records asserts that the total record count must be <= MAX_RECORD. A Metadata resource can therefore be created with more than MAX_RECORD entries. Any later call to update_records (even one that only updates existing keys) will fail the post-condition assert and abort, effectively preventing further updates until records are reduced via delete_records.\n- Where: create(...); check is only present in update_records(...)\n- Why it's a security issue: A malicious or buggy creation path can permanently lock out record updates for that token by exceeding the limit at creation time.\n- Potential impact: Denial of service for future updates to records; potential unexpected behavior in applications expecting the MAX_RECORD invariant.",
      "vulnerability_type": "input validation / denial of service",
      "severity": "medium",
      "confidence": 0.8,
      "location": "create(token, expiration_date, name, record_keys, record_values) function",
      "file": "metadata.move",
      "id": "00254fdd9cf946a1",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unchecked denominator in mul_div helpers allows division-by-zero abort",
      "description": "The helper functions mul_div_u64 and mul_div_u128 perform a*b/c without validating that c != 0. If these are called with c == 0, the operation will abort, reverting the entire transaction. Where: mul_div_u64() and mul_div_u128() (near their definitions). Why it's a security issue: If these helpers are used in higher-level logic with attacker-controlled inputs (common for math utilities), an attacker can cause predictable transaction aborts, resulting in denial-of-service for that code path. Potential impact: Transaction-level DoS for any caller using these helpers without pre-checks; broader protocol DoS if such helpers are used in critical flows.",
      "vulnerability_type": "arithmetic error / denial of service",
      "severity": "low",
      "confidence": 0.9,
      "location": "mul_div_u64() and mul_div_u128()",
      "file": "utils.move",
      "id": "d2c78d3d9f07f0fe",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unchecked weight lookup can abort for unknown denominations",
      "description": "get_voting_power and get_customized_voting_power borrow weights from a map using simple_map::borrow(&weight_map, &denom) without verifying that the denom exists in the weight map. If a delegation contains a denom that is missing from voting_power_weights, this borrow will abort. Where: get_voting_power() inside the balance loop (let weight = simple_map::borrow(&weight_map, &denom)); get_customized_voting_power() similarly. Why it's a security issue: The denominations come from external Stargate queries, so unexpected or newly introduced denoms can trigger an abort. An attacker that can influence delegations/denoms (e.g., by delegating staking tokens with different denom or causing anomalous query responses) can cause any transaction invoking these functions to revert. Potential impact: Transaction-level DoS for any functionality depending on voting power computation; potential protocol disruption if these helpers are used in system-critical flows.",
      "vulnerability_type": "unchecked external input / denial of service",
      "severity": "medium",
      "confidence": 0.85,
      "location": "get_voting_power(); get_customized_voting_power()",
      "file": "utils.move",
      "id": "8084c00299279e6a",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unbounded pagination/aggregation may cause gas exhaustion",
      "description": "get_delegations paginates and appends all DelegationResponse entries into a vector without limiting the number of pages or items. An address with a very large number of delegations or balances can cause excessive iteration, memory growth, and gas consumption. Where: get_delegations(), loop over pagination with vector::append of response.delegation_responses. Why it's a security issue: An attacker can create many small delegations across validators to inflate the number of records. Any function that calls get_delegations (directly or via get_voting_power/get_customized_voting_power) on such an address may consistently run out of gas and revert. Potential impact: Transaction-level DoS and potential disruption of batch or maintenance operations that rely on processing delegations.",
      "vulnerability_type": "unbounded iteration / gas exhaustion DoS",
      "severity": "low",
      "confidence": 0.7,
      "location": "get_delegations()",
      "file": "utils.move",
      "id": "89d4b98d5e1a93fd",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Potential u64 overflow when aggregating voting power",
      "description": "total_voting_power is a u64 and is incremented by values derived from bigdecimal::mul_by_u64_truncate for each balance across all delegations. With sufficiently large amounts and/or many entries, the sum can overflow u64 and abort. Where: get_voting_power() and get_customized_voting_power(), accumulation into total_voting_power. Why it's a security issue: The amounts and number of items are influenced by on-chain state returned via external queries. An attacker with large balances or numerous delegations can trigger overflow and cause a revert. Potential impact: Transaction-level DoS for any computation depending on these helpers.",
      "vulnerability_type": "integer overflow / denial of service",
      "severity": "low",
      "confidence": 0.6,
      "location": "get_voting_power(); get_customized_voting_power()",
      "file": "utils.move",
      "id": "30f1d845e4b2adb9",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unrestricted reward minting via set_reward + withdraw_delegations_reward",
      "description": "Any user who has (or creates) a delegation can arbitrarily set a reward for themselves using set_reward, then immediately withdraw it from the module\u2019s extension signer via withdraw_delegations_reward. There is no access control or cap on the reward amount. The transfer in withdraw_delegations_reward sends real coins from the test signer (object::generate_signer_for_extending) to the delegator using coin::transfer, enabling draining of that account if it holds funds. This occurs in set_reward() (public, no authorization checks) and withdraw_delegations_reward() where it reads the reward and transfers coin.amount to the delegator.",
      "vulnerability_type": "access control / unauthorized minting",
      "severity": "high",
      "confidence": 0.9,
      "location": "set_reward() and withdraw_delegations_reward() functions",
      "file": "mstaking.move",
      "id": "b3ec7b7588f562d2",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Over-slashing and potential underflow/DoS in slash_redelegations",
      "description": "In slash_redelegations, after computing slashing_coins for a redelegation, the code iterates over all delegations for the destination validator and subtracts the entire slashing_coins from each delegation indiscriminately (new_balances = sub_coins(balances, slashing_coins)). slashing_coins is not decremented across delegations, causing unrelated delegators on the destination validator to be over-slashed. Additionally, sub_coins assumes a.amount >= b.amount per denom; if any delegation balance is smaller than slashing_coins, subtraction underflows and aborts, causing a denial of service. This misapplication of slashing can corrupt delegation data and/or revert execution.",
      "vulnerability_type": "protocol manipulation / denial of service",
      "severity": "high",
      "confidence": 0.8,
      "location": "slash_redelegations() function, loop over test_state.delegation with new_balances = sub_coins(balances, slashing_coins)",
      "file": "mstaking.move",
      "id": "942b0d19777be29e",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Incorrect update of delegator_delegations in slash_redelegations (wrong validator target and unchecked index)",
      "description": "Within slash_redelegations, after adjusting a delegation on the destination validator, the code attempts to update the delegator's DelegatorDelegations list by searching for an entry where validator_address == validator_addr (the slashed source validator) instead of dst_validator_addr. The result of vector::find is not checked and the code proceeds to vector::remove using the returned index. If not found, the index may be invalid, leading to an out-of-bounds removal and abort, or removal of the wrong entry, corrupting the delegator\u2019s delegation state.",
      "vulnerability_type": "logic error / unchecked return leading to DoS",
      "severity": "medium",
      "confidence": 0.8,
      "location": "slash_redelegations() function, update of DelegatorDelegationsResponse using vector::find and vector::remove",
      "file": "mstaking.move",
      "id": "0b5ba3300a5b038a",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Missing validation on slash_factor can cause underflow and abort in slash_delegations",
      "description": "slash() is public and accepts an arbitrary slash_factor. In slash_delegations, slashing_amount = mul_by_u64_truncate(slash_factor, balance.amount) is subtracted unconditionally from balance.amount (reserve = balance.amount - slashing_amount). If slash_factor > 1, slashing_amount can exceed balance.amount, causing a u64 underflow and abort, leading to a denial of service. There is no validation that slash_factor is within [0, 1].",
      "vulnerability_type": "input validation / denial of service",
      "severity": "medium",
      "confidence": 0.75,
      "location": "slash() (public entry) and slash_delegations() where reserve = balance.amount - slashing_amount",
      "file": "mstaking.move",
      "id": "2782016fc0b8ca35",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Negative commission values allowed due to missing lower-bound checks",
      "description": "The module validates that commission-related values are <= 1 but does not enforce non-negativity. Specifically, check_valid_rate only asserts rate <= 1, and update_operator_commission does not call check_valid_rate at all. As a result, during registration and subsequent updates, commission_rate (and even commission_max_rate and commission_max_change_rate at registration) can be negative. Locations: check_valid_rate(), check_valid_commission_rates(), register_operator_store(), update_operator_commission(). This is a security issue because BigDecimal is signed, and allowing negative commission rates can invert fee flows or cause incorrect accounting when these values are later used in financial calculations by other modules (e.g., paying out more than intended or extracting funds by setting a negative fee). Potential impact includes loss of funds, protocol manipulation, or data corruption in downstream logic relying on commission invariants.",
      "vulnerability_type": "input validation / business logic",
      "severity": "high",
      "confidence": 0.9,
      "location": "check_valid_rate(), check_valid_commission_rates(), register_operator_store(), update_operator_commission()",
      "file": "operator.move",
      "id": "9d1efa1c6f0de78f",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    }
  ],
  "token_usage": {
    "input_tokens": 117166,
    "output_tokens": 91374,
    "total_tokens": 208540
  }
}